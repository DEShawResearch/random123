<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Random123: Random123: a Library of Counter-Based Random Number Generators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Random123
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Random123: a Library of Counter-Based Random Number Generators </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md0"></a>
Random123: a Library of Counter-Based Random Number Generators</h1>
<p>The Random123 library is a collection of counter-based random number generators (<a class="el" href="CBRNG.html">CBRNGs</a>) for CPUs (C and C++) and GPUs (CUDA and OpenCL), as described in <a href="http://dl.acm.org/citation.cfm?doid=2063405"><em>Parallel Random Numbers: As Easy as 1, 2, 3</em>, Salmon, Moraes, Dror &amp; Shaw, SC11, Seattle, Washington, USA, 2011, ACM </a>. They are intended for use in statistical applications and Monte Carlo simulation and have passed all of the rigorous SmallCrush, Crush and BigCrush tests in the <a href="http://www.iro.umontreal.ca/~simardr/testu01/tu01.html">extensive TestU01 suite</a> of statistical tests for random number generators. They are <b>not</b> suitable for use in cryptography or security even though they are constructed using principles drawn from cryptography.</p>
<p>The Random123 library is implemented entirely in header files. See <a href="#installation-and-testing">below</a>, for how to install and use the library, and how to generate documentation with doxygen.</p>
<p>CBRNGs are as fast as, or faster than conventional RNGs, much easier to parallelize, use minimal memory/cache resources, and require very little code. On modern architectures, the Random123 CBRNGs require a few cycles per byte of random data returned and return random data in convenient sizes (arrays of two or four elements, each of which is an unsigned integer of 32 or 64 bits). The range of random numbers is the full representable range of the 32 or 64 bit unsigned integer) The <code>&lt;Random123/uniform.h&gt;</code> header contains utility functions to convert 32- and 64-bit unsigned integers to open or closed ranges of single or double precision floating point numbers.</p>
<p>The Random123 library was written by John Salmon and Mark Moraes. It is available at <a href="https://github.com/DEShawResearch/random123">https://github.com/DEShawResearch/random123</a>. Archived releases are also available from <a href="http://deshawresearch.com/resources_random123.html">http://deshawresearch.com/resources_random123.html.</a> Please see the <a class="el" href="LICENSE.html">LICENSE</a> for terms and conditions.</p>
<h2><a class="anchor" id="autotoc_md1"></a>
Overview</h2>
<p>Unlike conventional RNGs, counter-based RNGs are <em>stateless</em> functions (or function classes i.e. functors) whose arguments are a <em>counter</em>, and a <em>key</em> that return a result of the same type as the counter. </p><pre class="fragment">    result = CBRNGname(counter, key)
</pre><p>The returned result is a deterministic function of the key and counter, i.e. a unique (counter, key) tuple will always produce the same result. The result is highly sensitive to small changes in the inputs, so that the sequence of values produced by simply incrementing the counter (or key) is effectively indistinguishable from a sequence of samples of a uniformly distributed random variable.</p>
<p>For all the CBRNGs in the Random123 library, the result and counter are the same type, specifically an array of <em>N</em> words, where words have a width of <em>W</em> bits, encapsulated in <a class="el" href="group__arrayNxW.html">r123arrayNxW</a> structs, or equivalently, for C++, in the <a class="el" href="namespacer123.html#acc1b0ed919ef806de26f5ff5b934b313">ArrayNxW</a> typedefs in the r123 namespace. Keys are usually also arrayMxW types, but sometimes M is a different size than the counter N (e.g. Philox keys have half the number of elements as the counter, Threefry and ARS have the same number, AES uses an opaque key type rather than an array) The N random numbers returned in <code>result.v[]</code> are unsigned integers of width W (32 or 64), and the range of the random numbers is the full range of the unsigned integer of that width (i.e. 0 to 2^W-1)</p>
<p>In C++, all public names (classes, structs, typedefs, etc) are in the <code>r123</code> namespace. In C, the public names (functions, enums, structs, typedefs) begin either with <code>r123</code> or with one of the RNG family names, e.g., <code>threefry</code>, <code>philox</code>, <code>ars</code>, <code>aesni</code>. The RNG functions themselves have names like <code>philox4x32</code>. C++ class names are capitalized, e.g., <code>Threefry4x32</code>.</p>
<h2><a class="anchor" id="autotoc_md2"></a>
\anchor families The different families of Random123 generators</h2>
<p>Several families of CBRNGs are available in this version of the library: </p><ul>
<li>
<a class="el" href="group__ThreefryNxW.html">Threefry</a> is a <b>non-cryptographic</b> adaptation of the Threefish block cipher from the <a href="http://www.skein-hash.info/">Skein Hash Function</a>. <br  />
 See <a class="el" href="group__ThreefryNxW.html#ga1c32939b65f84966c93677f4382ea36d">r123::Threefry2x32</a>, <a class="el" href="group__ThreefryNxW.html#gacb09a2dcfb7389769f0c58f45f132aaa">r123::Threefry4x32</a>, <a class="el" href="group__ThreefryNxW.html#ga2b54dd1b0d20f09239be5f8757f1f3db">r123::Threefry2x64</a>, <a class="el" href="group__ThreefryNxW.html#gae17c98bddf067365508ed0717f865e8b">r123::Threefry4x64</a>. </li>
<li>
<a class="el" href="group__PhiloxNxW.html">Philox</a> uses a Feistel network and integer multiplication. See <a class="el" href="group__PhiloxNxW.html#ga81659a3ee5a1ca9e2e85c5d725a1ea4f">r123::Philox2x32</a>, <a class="el" href="group__PhiloxNxW.html#gaafd54060af05012db410034e3c0ecdc4">r123::Philox4x32</a>, <a class="el" href="group__PhiloxNxW.html#ga616a669079ac25119353416c14d46426">r123::Philox2x64</a>, <a class="el" href="group__PhiloxNxW.html#ga7776f4d481b7c0ac00db70272a1c77f0">r123::Philox4x64</a>. The Nx64 forms are only available on hardware that supports 64-bit multiplication producing a 128-bit result. </li>
<li>
&lt;!AESNI--&gt; "AESNI" uses the Advanced Encryption Standard (AES) New Instruction, available on certain modern x86 processors (some models of Intel Westmere and Sandy Bridge, and AMD Interlagos, as of 2011). AESNI CBRNGs can operate on four 32bit words (internally converting them to the 128bit SSE type needed by the AES-NI instructions, or on a single m128i "word", which holds the SSE type. See <a class="el" href="structr123_1_1AESNI4x32.html">r123::AESNI4x32</a>, <a class="el" href="structr123_1_1AESNI1xm128i.html">r123::AESNI1xm128i</a>. </li>
<li>
<a class="el" href="group__AESNI.html">ARS</a> (Advanced Randomization System) is a <b>non-cryptographic</b> simplification of <a class="el" href="group__AESNI.html">AESNI</a>. See <a class="el" href="structr123_1_1ARS4x32__R.html">r123::ARS4x32_R</a>, <a class="el" href="structr123_1_1ARS1xm128i__R.html">r123::ARS1xm128i_R</a>. </li>
</ul>
<h2><a class="anchor" id="autotoc_md3"></a>
Installation and Testing</h2>
<p>The Random123 library is implemented entirely in header files. Thus, there is nothing to compile before using it and nothing to link after you <code>#include</code> it in your source files. Simply direct your C or C++ compiler to find the header files in the <code>include/</code> directory of the cloned repo and use the Random123 header files, types, and functions in your application.</p>
<p>Users and packagers are <b>STRONGLY ADVISED</b> run <code>make check</code> to compile and run the tests in <code>tests/</code> before using Random123 in an application (see tests/README). Do not use the library if any tests fail. (It is not a failure for a test to report that it cannot run because of missing hardware capabilities like 64bit multiply, SSE, AES-NI or compiler capabilities)</p>
<p>The top-level GNUmakefile also has "install", "html", and "install-html" targets. The former will copy header files to $(DESTDIR)$(includedir) (default: /usr/local/include). The second will run doxygen, replacing anything in docs/html. The last will install the documentation in $(DESTDIR)$(docdir)/html (default: /usr/local/doc/Random123/html).</p>
<h2><a class="anchor" id="autotoc_md4"></a>
Usage</h2>
<h3><a class="anchor" id="autotoc_md5"></a>
C++ API</h3>
<p>A typical C++ use case might look like:</p>
<pre class="fragment">#include &lt;Random123/philox.h&gt;

typedef r123::Philox4x32 RNG;
RNG rng;
RNG::ctr_type c={{}};
RNG::ukey_type uk={{}};
uk[0] = ???; // some user_supplied_seed
RNG::key_type k=uk;

for(...){
   c[0] = ???; // some loop-dependent application variable 
   c[1] = ???; // another loop-dependent application variable 
   RNG::ctr_type r = rng(c, k);
   // use the random values in r for some operation related to
   // this iteration on objectid
}
</pre><p>On each iteration, <code>r</code> contains an array of 4 32-bit random values that will not be repeated by any other call to <code>rng</code> as long as <code>c</code> and <code>k</code> are not reused.</p>
<p>In the example above, we use the <a class="el" href="group__PhiloxNxW.html#gaafd54060af05012db410034e3c0ecdc4">r123::Philox4x32</a>, but any of the other <a class="el" href="CBRNG.html">CBRNGs</a> would serve equally well. Also note that for most CBRNGs, the <code>ukey_type</code> and the <code>key_type</code> are identical; the code could just as well ignore the <code>ukey_type</code> and directly construct the <code>key_type</code>. However, for the <a class="el" href="group__AESNI.html">AESNI</a> CBRNGs, the <code>key_type</code> is opaque, and must be constructed from a <code>ukey_type</code>, as shown.</p>
<h3><a class="anchor" id="autotoc_md6"></a>
The C API</h3>
<p>In C, the example above could be written as: </p><pre class="fragment">#include &lt;Random123/philox.h&gt;

philox4x32_ctr_t c={{}};
philox4x32_ukey_t uk={{}};

uk.v[0] = user_supplied_seed;
philox4x32_key_t k = philox4x32keyinit(uk);

for(...){
    c.v[0] = ???; /* some loop-dependent application variable */
    c.v[1] = ???; /* another loop-dependent application variable */
    philox4x32_ctr_t r = philox4x32(c, k);
}
</pre><p>In C, access to the contents of the counter and key is through the fixed-size array member <code>v</code>.</p>
<h2><a class="anchor" id="autotoc_md7"></a>
The CUDA platform</h2>
<p>All relevant functions in the C and C++ APIs for Random123 are declared as CUDA device functions if they are included in a CUDA kernel source file and compiled with a CUDA compiler (nvcc). They can be used exactly as described/documented for regular C or C++ programs. It is now possible to use Random123 functions in both the host portion and the device portion of the same .cu source file. The Nx32 forms were faster than the Nx64 variants on 32-bit GPU architectures in 2011, but we haven't measured this recently.</p>
<p>It has been reported that Random123 uses 16 bytes of static memory per thread. This is undesirable and not intentional, but we do not have a workaround other than to suggest adjusting memory allocation accordingly.</p>
<p>The pi_cuda.cu and pi_cudapp.cu examples illustrate the use of CUDA.</p>
<p>In a machine with different GPUs, the R123EXAMPLE_ENVCONF_CUDA_DEVICE environment variable can be set to a unique substring of the CUDA GPU device name to select a specific GPU (else examples try to choose the GPU with the most cores)</p>
<h2><a class="anchor" id="autotoc_md8"></a>
The OpenCL platform</h2>
<p>The functions in the Random123 C API can all be used in OpenCL kernels, just as in regular C functions. As with CUDA, the Nx32 forms are faster than the Nx64 variants on current (2011) 32-bit GPU architectures.</p>
<p>The <code>pi_opencl.c</code> and <code>pi_opencl_kernel.ocl</code> examples illustrate the use of OpenCL.</p>
<p>In a machine with different OpenCL devices, the R123EXAMPLE_ENVCONF_OPENCL_DEVICE environment variable can be set to a unique substring of the OpenCL device name to select a specific OpenCL device (else examples try to choose the device with the most cores)</p>
<h2><a class="anchor" id="autotoc_md9"></a>
C++11 &lt;random&gt; interface</h2>
<p>In addition to the stateless ("pure/functional") C++ API above, the Random123 package includes two C++ classes that leverage the C++11 &lt;random&gt; API.</p>
<ul>
<li>
r123::MicroURNG provides an adapter class that provides a more conventional interface compatible with the C++11 URNG (uniform random number generator) API; the MicroURNG adapter can be used with C++11 random number distributions and is fast/lightweight enough that a new MicroURNG can be instantiated with a unique key,counter tuple and used for each call to a distribution, there is little or no overhead to creating billions of unique MicroURNGs. This adapter retains one of the key advantages of CBRNGs &ndash; complete application control over the RNG state. </li>
<li>
r123::Engine provides the C++11 Random Engine API. This can also be used with any of the C++11 random distributions, but sacrifices the application control over RNG state that is a defining characteristic of CBRNGs. </li>
</ul>
<h2><a class="anchor" id="autotoc_md10"></a>
The GNU Scientific Library (GSL) interface</h2>
<p>In addition to the stateless ("pure/functional") C API above, the Random123 package includes two C adapter interfaces to the <a href="http://www.gnu.org/s/gsl/">GNU Scientific Library (GSL).</a></p>
<ul>
<li>
The GSL_MICRORNG macro allows the application to define a GSL random number generator. It can be used with GSL random distributions but still provides the application with complete control over the RNG state (it is analogous to the MicroURNG class, in that it uses shorter periods, and is intended to be instantiated in large numbers for a few calls to the random distribution). </li>
<li>
The GSL_CBRNG macro allows the application to create a GSL RNG with a completely conventional interface, sacrificing application control over the internal RNG state. </li>
</ul>
<h2><a class="anchor" id="autotoc_md11"></a>
Generating uniformly distributed and Gaussian distributed floats and doubles</h2>
<p>The Random123 library provides generators for uniformly distributed random <b>integers</b>. Often, applications want random <b>real</b> values or samples from other distributions. The general problem of generating samples from arbitrary distributions is beyond the scope of the Random123 library. One can, of course, use GSL or MicroURNG and the distributions in the C++11 &lt;random&gt; library, but a few simple cases are common enough that all that extra machinery seems like overkill. We have included a few generic conversion utilities which developers may find useful.</p>
<ul>
<li>
uniform.hpp - C++ functions that convert random integers to random, uniformly distributed floating point values. </li>
<li>
u01fixedpt.h - C functions that convert random integers to random, uniformly distributed, equi-spaced, i.e., fixed point, values. </li>
<li>
boxmuller.hpp - C++ functions that take two uniformly distributed integers (32 or 64 bit) and return a pair of Gaussian distributed floats or doubles. </li>
</ul>
<p>The Box-Muller method of generating Gaussian random variables is particularly well suited to Random123 because it deterministically consumes exactly two uniform randoms to generate exactly two gaussian randoms. It uses math library functions: sincos, log and sqrt which may be slow on some platforms, but which are surprisingly fast on others. Notably, on GPUs, the lack of branching in the Box-Muller method and hardware support for math functions overcomes the transcendental function overhead, making it the fastest generator of Gaussians that we are aware of.</p>
<h2><a class="anchor" id="autotoc_md12"></a>
Examples</h2>
<p>The examples/ directory, contains example code intended to illustrate use of the library.</p>
<p>Complete, short programs estimate pi by counting the number of random points that fall inside a circle inscribed in a square, demonstrating the C, C++, AES, GSL, OpenCL, CUDA and C++11 APIs. The environment variable R123EXAMPLE_ENVCONF_SEED can be set to any unsigned integer value to run the example with a different seed. Many of the pi_* examples run different numbers of iterations if that number is specified as the first argument on the command line.</p>
<h3><a class="anchor" id="autotoc_md13"></a>
Tests and Benchmarks</h3>
<p>The tests/ directory contains tests and benchmarks. This code is complicated due to the fact that it is largely "single source" for CUDA, OpenCL and CPU implmentations. Developers are strongly discouraged from emulating its style. It contains: </p><ul>
<li>
Unit tests for individual components and "known-answer-tests", which should be run to ensure that these RNGs build correctly on desired platforms. These help to provide assurance that the code is being compiled correctly. </li>
<li>
A variety of timing harnesses are provided which measure performance of a variety of generators in different programming environments. </li>
</ul>
<h2><a class="anchor" id="autotoc_md14"></a>
Portability</h2>
<p>Although we have done our best to make Random123 portable and standards conforming, it is an unfortunate fact that there is no portable code. There is only code that has been ported.</p>
<p>Prior to release, we test Random123 on a variety of systems and with a variety of toolchains that are readily available to us. Our current test environment includes:</p>
<ul>
<li>
Linux, gcc-5.2.0, 6.3.0, 8.1.0, 10.1.0 using -march=native on Xeon hardware with AES and SSE4_2 and AVX2 support. </li>
<li>
Linux, gcc-5.2.0 using -m32. </li>
<li>
Linux, clang-8.0.0 with libc++ (8.0.0) on Xeon hardware. </li>
<li>
Linux, CentOS7 using the vendor supplied gcc toolchain (4.8.5-16). </li>
<li>
Linux, Ubuntu 16.04(LTS) using the vendor supplied gcc toolchain (5.4.0-6ubuntu1-16.04.11). </li>
<li>
Linux, Ubuntu 16.04(LTS) using OpenCL beignet 1.1.1-2 and <a href="https://github.com/intel/compute-runtime/releases/tag/19.07.12410">https://github.com/intel/compute-runtime/releases/tag/19.07.12410</a> </li>
<li>
Linux, Ubuntu 18.04(LTS) with clang-11.0.1 and both libc++ and libstdc++. </li>
<li>
Linux, icc-18.0.3 and 19.1.2.254 on Xeon hardware with AES, SSE4 and AVX2 support. </li>
<li>
Linux, NVIDIA CUDA 10.0.130 with GTX 980 and 1080, and Titan RTX (aka Turing) hardware. </li>
<li>
MacOS, with Xcode-10.1 and Metal on a 2018 Mac mini. </li>
</ul>
<p>In the past, we have tested Random123 with additional toolchains and hardware. Although we no longer test on these platforms, we know of no reason that they should not work.</p>
<ul>
<li>
Linux, gcc (multiple versions from 3.4.3 through 6.3.0), on x86_64. </li>
<li>
Linux, gcc-4.1.2 and 4.4.1 on i686. </li>
<li>
Linux, gcc-4.8 on ARMv7 (32bit) Freescale/NXP LS1021A &amp; ARM A53 (64bit) Freescale/NXP 1043A. </li>
<li>
Linux, clang-2.9, 3.0, 3.1, 3.3 and 3.6 on x86_64. </li>
<li>
Linux, clang-3.0 and 3.1 with lib++ (2012-04-19 svn checkout) on x86_64. </li>
<li>
Linux, clang-8.0.0 with libc++ on x86_64 </li>
<li>
Linux, open64-4.2.4 on x86_64. </li>
<li>
Linux, Intel icc and icpc 12.0.2 on x86_64. </li>
<li>
Linux, NVIDIA CUDA 4.1.15, 4.2.6, 5.5.22 and 7.5.1. (NOTE: We recommend against the use of CUDA before 4.1) </li>
<li>
Linux, OpenCL (NVIDIA SDK 4.0.17) on GTX480, M2090, GTX580 and GTX680 GPUs. </li>
<li>
Linux, OpenCL (AMD APP SDK 2.4 or 2.5), on x86_64 CPUs and Radeon HD6970 GPUs. </li>
<li>
Linux, OpenCL (Intel OpenCL 1.5), on x86_64 CPUs. </li>
<li>
Solaris, both gcc-3.4.3 and Sun C/C++ 5.8, on x86_64. </li>
<li>
FreeBSD 8.2, gcc-4.2.1, on x86_64. </li>
<li>
MacOS X 5.8, gcc-4.0.1, on i686. </li>
<li>
MacOS X 5.8, llvm-2.9.1 on i686 (problems with catching C++ exceptions). </li>
<li>
Windows 7, Microsoft Visual Studio, version 10.0, Microsoft C/C++ compiler 16.00. </li>
</ul>
<p>Others have reported success on </p><ul>
<li>
MacOS, OpenCL on x86_64 CPUs </li>
<li>
Linux, gcc-4.7.2 on Powerpc64 (BlueGene/Q) </li>
<li>
Linux, Portland Group Compiler on Powerpc64 (BlueGene/Q) </li>
<li>
Linux, IBM xlc on Powerpc64 (BlueGene/Q) </li>
<li>
MacOS, Metal on x86_64 CPUs and AMD Radeon R9 M380 GPU </li>
<li>
MacOS Sierra and Scientific Linux with Nvidia GPU and CUDA 8 </li>
<li>
Linux, on s390x </li>
</ul>
<h2><a class="anchor" id="autotoc_md15"></a>
Warnings</h2>
<p>With some compilation options, the CUDA nvcc compiler warns about unreachable code in array.h. The compiler doesn't recognize that the code that is unreachable for some values of some macro parameters, is actually reachable for other values of the parameters. It is possible to disable that particular warning for a specific compilation unit by adding -Wcudafe&#160;&ndash;diag_suppress=111 to the compilation command line.</p>
<p>On our ARMv7 test platform, we suspect a compiler bug with -O3, which does not seem to affect Random123 code itself, but produces nondeterministic results from time_serial. The offending compiler version was "aarch64-fsl-linux-gcc&amp;nbsp;(Linaro&amp;nbsp;GCC&amp;nbsp;4.8-2014.04)&amp;nbsp;4.8.3&amp;nbsp;20140401&amp;nbsp;(prerelease)". We slightly reordered a couple of innocuous statements (a timer() and dprintf() call) in time_serial to avoid the bug, but we would avoid -O3 on ARMv7 with that particular version of the compiler at least.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Contributors</h2>
<p>We welcome bug reports, bug fixes, ports, general feedback and other enhancements to the <a href="https://github.com/DEShawResearch/random123/issues">issues</a> and <a href="https://github.com/DEShawResearch/random123/pulls">pull requests</a> pages of our <a href="https://github.com/DEShawResearch/random123/">github repo</a>.</p>
<p>We are grateful for contributed bug-fixes and portability enhancements from the following users: </p><ul>
<li>
Geoffrey Irving and Gabriel Rockefeller - BlueGene/Q and powerpc ports </li>
<li>
Yan Zhou - MacOS and clang ports </li>
<li>
David Lawrie - allowing 64-bit philox to compile for both host and device with CUDA </li>
<li>
Bogdan Opanchuk - pointing out the inconsistent rotation constants in the implementation of threefry2xW in version 1.07 and earlier. </li>
<li>
Tom Schoonjans - Support for Metal (Apple's successor to OpenCL) </li>
<li>
Karl Magdsick - documentation in uniform.hpp </li>
<li>
KT Thompson - Visual Studio 2015 and ibm xlc compiler ports </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jan 29 2021 14:24:56 for Random123 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
